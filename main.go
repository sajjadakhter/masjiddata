package main

import (
	"encoding/json"
	"fmt"
	"log"
	"net/http"
	"os"
	"strconv"
	"strings"
)

type SalahTimeRecord struct {
	Month     int         `json:"month"`
	Year      int         `json:"year"`
	Salatimes []Salatimes `json:"salatimes"`
}
type SalahTime struct {
	Hour int `json:"hour"`
	Min  int `json:"min"`
}
type Salatimes struct {
	Month    int
	Day      int
	Fajar18   int `json:"fajar18"`
	Fajar15   int `json:"fajar15"`
	Sunrise   int `json:"sunrise"`
	//Ishraq    SalahTime `json:"ishraq"`
	//Chasht    SalahTime `json:"chasht"`
	//Zawal     SalahTime `json:"zawal"`
	Zuhar     int `json:"zuhar"`
	AsrShafai int `json:"asarshafai"`
	AsrHanfi  int `json:"asrhanfi"`
	Maghrib   int `json:"maghrib"`
	Isha15    int `json:"isha15"`
	Isha18    int `json:"isha18"`
}

type Salatimes2 struct {
	Fajar18   int `json:"fajar18"`
	Fajar15   int `json:"fajar15"`
	Sunrise   int `json:"sunrise"`
	//Ishraq    SalahTime `json:"ishraq"`
	//Chasht    SalahTime `json:"chasht"`
	//Zawal     SalahTime `json:"zawal"`
	Zuhar     int `json:"zuhar"`
	AsrShafai int `json:"asarshafai"`
	AsrHanfi  int `json:"asrhanfi"`
	Maghrib   int `json:"maghrib"`
	Isha15    int `json:"isha15"`
	Isha18    int `json:"isha18"`
}

type SalahTimeYear struct {
	Year      int         `json:"year"`
	Salatimes [12][31][9] int `json:"salatimes"` //[month][day][salah]
}

func convertStrToMin(str string) int {
	parts := strings.Split(strings.Split(str, " ")[0], ":")
	h , _ := strconv.Atoi(parts[0])
	m , _ := strconv.Atoi(parts[1])
	return  (h*60) + m
}

func convertStrToSalaTime(str string) SalahTime {
	parts := strings.Split(strings.Split(str, " ")[0], ":")
	h , _ := strconv.Atoi(parts[0])
	m , _ := strconv.Atoi(parts[1])
	return SalahTime{ Hour: h, Min: m}
}

type Multipart struct {
	Multipart string
}


func main() {
	year := 2020
	//for i:=1; i < 13; i++ {
	//	data := getMonthData2( year)
	//	file, _ := json.MarshalIndent(data, "", " ")
	//	_ = ioutil.WriteFile(fmt.Sprintf("%v.json", i), file, 0644)
	//}


		getMonthData2( year)
		//file, _ := json.MarshalIndent(times, "", " ")
		//_ = ioutil.WriteFile(fmt.Sprintf("salahtimes.json"), file, 0644)

}

func writeMultipart(begin bool) {
	 tag := Multipart{"begin"};
	 fileMode := os.O_CREATE|os.O_WRONLY;
	if !begin {
		tag.Multipart = "end"
		fileMode = os.O_APPEND|os.O_CREATE|os.O_WRONLY
	}
	t, _ := json.Marshal(tag)
	f, err := os.OpenFile("./1/salahtimes/salahtimes.json", fileMode, 0644)
	if err != nil {
		log.Println(err)
	}
	if _, err := f.WriteString( fmt.Sprintf("%s\n", string(t))); err != nil {
		log.Println(err)
	}
}

func getMonthData2( year int)  {
	//var times SalahTimeYear
	writeMultipart(true)
	for month := 0; month < 12; month++ {
		resp1, err := http.Get("http://api.aladhan.com/v1/calendarByCity?city=Buffalo&country=USA&state=NY&school=0&method=99&methodSettings=15,null,15" + fmt.Sprintf("&year=%v&month=%v", year, month+1))
		resp2, err := http.Get("http://api.aladhan.com/v1/calendarByCity?city=Buffalo&country=USA&state=NY&school=1&method=99&methodSettings=18,null,18" + fmt.Sprintf("&year=%v&month=%v", year, month+1))

		if err != nil {
			log.Fatalln(err)
		}

		var d1 AutoGenerated
		json.NewDecoder(resp1.Body).Decode(&d1)

		var d2 AutoGenerated
		json.NewDecoder(resp2.Body).Decode(&d2)

		//fmt.Printf("%+v", decoded)

		if d1.Code == 200 && d2.Code == 200 {
			for i, _ := range d1.Data {
				//fmt.Printf("%v:%v\n", v.Date.Gregorian.Month.Number,  v.Date.Gregorian.Day)

				//times.Salatimes[month][i][0] = convertStrToMin(d1.Data[i].Timings.Fajr)
				//times.Salatimes[month][i][1] = convertStrToMin(d2.Data[i].Timings.Fajr)
				//
				//times.Salatimes[month][i][2] = convertStrToMin(d1.Data[i].Timings.Sunrise)
				//
				//times.Salatimes[month][i][3] = convertStrToMin(d1.Data[i].Timings.Dhuhr)
				//
				//times.Salatimes[month][i][4] = convertStrToMin(d1.Data[i].Timings.Asr)
				//times.Salatimes[month][i][5] = convertStrToMin(d2.Data[i].Timings.Asr)
				//
				//times.Salatimes[month][i][6] = convertStrToMin(d1.Data[i].Timings.Sunset)
				//
				//times.Salatimes[month][i][7] = convertStrToMin(d1.Data[i].Timings.Isha)
				//times.Salatimes[month][i][8] = convertStrToMin(d2.Data[i].Timings.Isha)

				var times Salatimes
				times.Month = month + 1
				times.Day,_ = strconv.Atoi(d1.Data[i].Date.Gregorian.Day)
				times.Fajar15 = convertStrToMin(d1.Data[i].Timings.Fajr)
				times.Fajar18 = convertStrToMin(d2.Data[i].Timings.Fajr)

				times.Sunrise = convertStrToMin(d1.Data[i].Timings.Sunrise)

				times.Zuhar = convertStrToMin(d1.Data[i].Timings.Dhuhr)

				times.AsrShafai = convertStrToMin(d1.Data[i].Timings.Asr)
				times.AsrHanfi = convertStrToMin(d2.Data[i].Timings.Asr)

				times.Maghrib = convertStrToMin(d1.Data[i].Timings.Sunset)

				times.Isha15 = convertStrToMin(d1.Data[i].Timings.Isha)
				times.Isha18 = convertStrToMin(d2.Data[i].Timings.Isha)

				fmt.Printf("%v %+v\n", d1.Data[i].Date.Gregorian.Day, times)
				//st.Salatimes = append(st.Salatimes, times)
				//fmt.Printf("index: %v, day %v/%v, Fajar15 %v\t Fajar 18 %v\n", i, d1.Data[i].Date.Gregorian.Day, d2.Data[i].Date.Gregorian.Day, convertStrToSalaTime(d1.Data[i].Timings.Fajr), convertStrToSalaTime(d2.Data[i].Timings.Fajr));

				t, _ := json.Marshal(times)
				f, err := os.OpenFile("./1/salahtimes/salahtimes.json", os.O_APPEND|os.O_CREATE|os.O_WRONLY, 0644)
				if err != nil {
					log.Println(err)
				}
				if _, err := f.WriteString( fmt.Sprintf("%s\n", string(t))); err != nil {
					log.Println(err)
				}
			}
		}
	}

	writeMultipart(false)
	//file, _ := json.Marshal(times.Salatimes)
	//_ = ioutil.WriteFile(fmt.Sprintf("./1/salahtimes/salahtimes.json"), file, 0644)

}


func getMonthData(month int, year int) SalahTimeRecord {
	resp1, err := http.Get("http://api.aladhan.com/v1/calendarByCity?city=Buffalo&country=USA&state=NY&school=0&method=99&methodSettings=15,null,15"+fmt.Sprintf("&year=%v&month=%v",year, month))
	resp2, err := http.Get("http://api.aladhan.com/v1/calendarByCity?city=Buffalo&country=USA&state=NY&school=1&method=99&methodSettings=18,null,18"+fmt.Sprintf("&year=%v&month=%v",year, month))

	st := SalahTimeRecord{ Month: month, Year: year}
	if err != nil {
		log.Fatalln(err)
	}

	var d1 AutoGenerated
	json.NewDecoder(resp1.Body).Decode(&d1)

	var d2 AutoGenerated
	json.NewDecoder(resp2.Body).Decode(&d2)

	//fmt.Printf("%+v", decoded)

	if d1.Code == 200 && d2.Code == 200 {
		for i, _ := range d1.Data {
			//fmt.Printf("%v:%v\n", v.Date.Gregorian.Month.Number,  v.Date.Gregorian.Day)
			var times Salatimes
			times.Fajar15 = convertStrToMin(d1.Data[i].Timings.Fajr)
			times.Fajar18 = convertStrToMin(d2.Data[i].Timings.Fajr)

			times.Sunrise = convertStrToMin(d1.Data[i].Timings.Sunrise)

			times.Zuhar = convertStrToMin(d1.Data[i].Timings.Dhuhr)

			times.AsrShafai = convertStrToMin(d1.Data[i].Timings.Asr)
			times.AsrHanfi = convertStrToMin(d2.Data[i].Timings.Asr)

			times.Maghrib = convertStrToMin(d1.Data[i].Timings.Sunset)

			times.Isha15 = convertStrToMin(d1.Data[i].Timings.Isha)
			times.Isha18 = convertStrToMin(d2.Data[i].Timings.Isha)

			fmt.Printf("%v %+v\n", d1.Data[i].Date.Gregorian.Day, times)
			st.Salatimes = append(st.Salatimes, times)
			//fmt.Printf("index: %v, day %v/%v, Fajar15 %v\t Fajar 18 %v\n", i, d1.Data[i].Date.Gregorian.Day, d2.Data[i].Date.Gregorian.Day, convertStrToSalaTime(d1.Data[i].Timings.Fajr), convertStrToSalaTime(d2.Data[i].Timings.Fajr));

		}
	}
	return st
}

type AutoGenerated struct {
	Code   int    `json:"code"`
	Status string `json:"status"`
	Data   []Data `json:"data"`
}
type Timings struct {
	Fajr     string `json:"Fajr"`
	Sunrise  string `json:"Sunrise"`
	Dhuhr    string `json:"Dhuhr"`
	Asr      string `json:"Asr"`
	Sunset   string `json:"Sunset"`
	Maghrib  string `json:"Maghrib"`
	Isha     string `json:"Isha"`
	Imsak    string `json:"Imsak"`
	Midnight string `json:"Midnight"`
}
type Weekday struct {
	En string `json:"en"`
}
type Month struct {
	Number int    `json:"number"`
	En     string `json:"en"`
}

//type Designation struct {
//	Abbreviated string `json:"abbreviated"`
//	Expanded    string `json:"expanded"`
//}
type Gregorian struct {
	Date        string      `json:"date"`
	Format      string      `json:"format"`
	Day         string      `json:"day"`
	Weekday     Weekday     `json:"weekday"`
	Month       Month       `json:"month"`
	Year        string      `json:"year"`
	//Designation Designation `json:"designation"`
}
//type Weekday struct {
//	En string `json:"en"`
//	Ar string `json:"ar"`
//}
//type Month struct {
//	Number int    `json:"number"`
//	En     string `json:"en"`
//	Ar     string `json:"ar"`
//}
//type Hijri struct {
//	Date        string      `json:"date"`
//	Format      string      `json:"format"`
//	Day         string      `json:"day"`
//	Weekday     Weekday     `json:"weekday"`
//	Month       Month       `json:"month"`
//	Year        string      `json:"year"`
//	Designation Designation `json:"designation"`
//	Holidays    []string    `json:"holidays"`
//}
type Date struct {
	Readable  string    `json:"readable"`
	Timestamp string    `json:"timestamp"`
	Gregorian Gregorian `json:"gregorian"`
	//Hijri     Hijri     `json:"hijri"`
}
type Params struct {
	Fajr int `json:"Fajr"`
	Isha int `json:"Isha"`
}
type Method struct {
	ID     int    `json:"id"`
	Name   string `json:"name"`
	Params Params `json:"params"`
}
type Offset struct {
	Imsak    int `json:"Imsak"`
	Fajr     int `json:"Fajr"`
	Sunrise  int `json:"Sunrise"`
	Dhuhr    int `json:"Dhuhr"`
	Asr      int `json:"Asr"`
	Maghrib  int `json:"Maghrib"`
	Sunset   int `json:"Sunset"`
	Isha     int `json:"Isha"`
	Midnight int `json:"Midnight"`
}
type Meta struct {
	Latitude                 float64 `json:"latitude"`
	Longitude                float64 `json:"longitude"`
	Timezone                 string  `json:"timezone"`
	Method                   Method  `json:"method"`
	LatitudeAdjustmentMethod string  `json:"latitudeAdjustmentMethod"`
	MidnightMode             string  `json:"midnightMode"`
	School                   string  `json:"school"`
	Offset                   Offset  `json:"offset"`
}
type Data struct {
	Timings Timings `json:"timings"`
	Date    Date    `json:"date"`
	Meta Meta `json:"meta"`
}
